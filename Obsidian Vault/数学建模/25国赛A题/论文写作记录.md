## 问题背景与分析
### 问题背景

### 问题分析
#### 问题一

问题一针对单枚导弹 M1 的干扰场景，在投放参数与延时参数均已给定的条件下，需依据导弹、无人机及干扰弹的运动学方程，结合遮蔽判据，即烟幕云团与 “导弹 — 真目标” 视线的相交条件，定量计算真目标被有效遮蔽的持续时长。

该问题的核心在于：构建导弹、无人机、干扰弹及烟幕云团的轨迹数学模型；推导遮蔽判据的解析表达式，包括云团中心在 “导弹 — 目标” 视线上的投影参数\(u^*\)与云团中心到该视线的垂直距离\(d_\perp\)；在有效时间区间内求解满足遮蔽判据的时刻集合，并计算该集合的时间测度，即总遮蔽时长。问题一作为整个研究的模型基础，所建立的遮蔽判据与时长计算方法，为后续各类干扰策略优化问题提供了关键的理论依据与数值计算框架。
#### 问题二
在问题二中，约束条件放宽：无人机可以调整航向角、飞行速度、投放时刻和延时。此时，需要构建一个**单弹–单导弹遮蔽优化模型**，以最大化有效遮蔽时长为目标函数，约束包括无人机速度范围、等高直线飞行以及投放时刻等。

这是一个**四维决策变量的非线性优化问题**。由于遮蔽判据难以解析化简，通常采用离散化搜索或启发式算法来寻找近优解。问题二的意义在于，从“计算时长”过渡到“优化策略”，体现了模型的可控性与扩展性。

这一段还需要修改为：从我们作者的视角出发




## 基本模型
# 基本模型与问题描述

本文研究“干扰云团对来袭导弹遮蔽真目标”的问题，旨在建立统一、可计算的数学模型，并在此基础上推导遮蔽判据与遮蔽时长的计算方法，为后续优化问题提供理论依据。

---

## 1. 坐标系与符号约定

建立空间直角坐标系，以“假目标”为原点 \$O=(0,0,0)\$，水平面为 \$xy\$ 平面，竖直方向为 \$+z\$ 轴。真目标近似为半径 \$r\_T=7,\mathrm{m}\$、高度 \$h\_T=10,\mathrm{m}\$ 的圆柱体，其下底面圆心位于 \$(0,200,0)\$，几何中心为

$$
\mathbf T_c=(0,200,5).
$$

若需严格保证目标整体被遮蔽，可将目标表面离散为一组代表点 \${\mathbf P\_m}\$，并对每一代表点分别检验遮蔽条件。

---

## 2. 运动学模型

问题涉及导弹、无人机、干扰弹与云团的运动学过程，均以矢量形式表述如下。

### 2.1 导弹轨迹

设第 \$k\$ 枚导弹的初始位置为 \$\mathbf M\_{k0}\$，飞行方向直指原点，其单位方向向量为

$$
\hat{\mathbf u}_k=\frac{\mathbf 0-\mathbf M_{k0}}{\|\mathbf M_{k0}\|}.
$$

假定导弹恒速 \$v\_m\$ 匀速直线飞行，则轨迹为

$$
\boxed{\mathbf M_k(t)=\mathbf M_{k0}+v_m t\,\hat{\mathbf u}_k}\qquad (t\ge0). \tag{1}
$$

### 2.2 无人机轨迹与投放

无人机 \$j\$ 自初始位置 \$\mathbf F\_{j0}\$ 以速度 \$v\_j\$ 匀速直线飞行，航向为

$$
\hat{\mathbf q}_j=(\cos\psi_j,\sin\psi_j,0),
$$

其位置为

$$
\boxed{\mathbf F_j(t)=\mathbf F_{j0}+v_j t\,\hat{\mathbf q}_j}\qquad (t\ge0). \tag{2}
$$

第 \$i\$ 枚干扰弹自无人机 \$j\$ 于时刻 \$t\_{j,i}^{\mathrm{drop}}\$ 投放，引信延时 \$\tau\_{j,i}\$，则起爆时刻为

$$
\boxed{t_{j,i}^{\mathrm{exp}}=t_{j,i}^{\mathrm{drop}}+\tau_{j,i}}. \tag{3}
$$

### 2.3 干扰弹与云团轨迹

忽略空气阻力，干扰弹在投放后作初速为 \$\mathbf v\_j=v\_j\hat{\mathbf q}*j\$ 的抛体运动，投放点为 \$\mathbf D*{j,i}=\mathbf F\_j(t\_{j,i}^{\mathrm{drop}})\$，则起爆点为

$$
\boxed{\mathbf C_{j,i}=\mathbf D_{j,i}+\mathbf v_j\,\tau_{j,i}+\tfrac{1}{2}(0,0,-g)\tau_{j,i}^2}. \tag{4}
$$

起爆后形成半径为 \$R\$ 的烟幕球体，其中心沿竖直方向以速率 \$v\_s\$ 匀速下沉，在有效时长 \$T\_s\$ 内可表示为

$$
\boxed{\mathbf C_{j,i}(t)=\mathbf C_{j,i}+(0,0,-v_s)(t-t_{j,i}^{\mathrm{exp}})},\qquad t\in[t_{j,i}^{\mathrm{exp}},t_{j,i}^{\mathrm{exp}}+T_s]. \tag{5}
$$

---

## 3. 遮蔽判据

给定目标代表点 \$\mathbf P\$，在时刻 \$t\$，导弹位置为 \$\mathbf M(t)\$，云团中心位置为 \$\mathbf C(t)\$，定义

$$
\mathbf A(t)=\mathbf P-\mathbf M(t),\qquad \mathbf B(t)=\mathbf C(t)-\mathbf M(t).
$$

云团中心在“导弹—目标”连线上的投影参数为

$$$
u^*(t)=\frac{\mathbf B(t)\cdot\mathbf A(t)}{\|\mathbf A(t)\|^2},$$

云团中心至该直线的垂直距离为

$$d_{\perp}^2(t)=\|\mathbf B(t)\|^2-\frac{(\mathbf B(t)\cdot\mathbf A(t))^2}{\|\mathbf A(t)\|^2}.$$

**判据**：若且仅若满足条件

$$

\boxed{0\le \nu^*(t)\le 1 \quad \text{且}\quad d\_{\perp}(t)\le R}\tag{6}

$$

则在时刻 $t$，该云团能够遮蔽代表点 $\mathbf P$。

---

## 4. 有效遮蔽时间与集合表述

对单枚云团 $(j,i)$ 与单枚导弹 $k$，其有效遮蔽时间集合为

$$

\mathcal S\_{j,i}^{(k)}={t\in\[t\_{j,i}^{\mathrm{exp}},t\_{j,i}^{\mathrm{exp}}+T\_s]\mid \text{式}(6)成立}. \tag{7}

$$

对导弹 $k$，所有云团的总遮蔽时间集合为

$$

\boxed{\mathcal S^{(k)}=\bigcup\_{j,i}\mathcal S\_{j,i}^{(k)}}\qquad \text{总遮蔽时长 }\boxed{\mathcal T^{(k)}=\mu(\mathcal S^{(k)})}. \tag{8}

$$

若要求多枚导弹同时被遮蔽，则定义

$$

\boxed{\mathcal S^{\mathrm{all}}=\bigcap\_k\mathcal S^{(k)},\qquad \mathcal T^{\mathrm{all}}=\mu(\mathcal S^{\mathrm{all}})}. \tag{9}

$$

其中 $\mu(\cdot)$ 表示集合的时间长度。


A题.pdf是竞赛题目，目前我要写问题二的求解，问题二解题是承接基本模型与问题一的求解的，但在该题中，由于复杂度提升，本文后续将圆柱体近似看作位于（0，200，5）的一直点进行计算。一开始我们的思路与问题一中的思路相似就是这样，并且编写了 第二题.ipynb 文档对该题进行求解，采用sympy库对基本模型中的遮蔽条件的不等式进行求解，方法为Nelder-Mead，具体思路参见文件中，帮我写成论文形式。但这个方法效率不高，在经过迭代次数: 500, 函数评估次数: 862, 用时: 322.094601 秒, 终止信息: Maximum number of iterations has been exceeded.
优化结果: [ 3.11934928 94.10836348  0.57246561  3.11997702]
最大遮蔽时长: 4.666283934618775。于是采用粒子群算法进行改进，简单介绍一下粒子群算法，显然粒子群算法需要进行更加大量的计算，而先前的计算方法会导致采用粒子群算法进行计算的时间及其大，经过分析，发现计算时间主要是由函数shielding_duration消耗，于是以下对该函数进行优化。该函数用于解遮蔽条件不等式，采用sympy的啥啥啥，经过分析，该不等式能够等价为一个四次多项式不等式方程，于是采用一、向量化与多项式化

记时间变量 t。

导弹到目标代表点 P 的向量 A(t) 与云团中心到导弹的向量 B(t)：

导弹直线匀速：M(t) = M0 + vm t u_m，其中 u_m 为单位方向（指向原点）。
目标代表点常量：P。
云团中心：C(t) = C0 + (0,0,-vs) (t - t_e)。
定义
A(t) = P − M(t) = A0 + A1 t，其中
A0 = P − M0
A1 = −vm u_m
B(t) = C(t) − M(t) = B0 + B1 t，其中
B0 = C0 − M0 + (0,0,vs) t_e
B1 = −vm u_m − (0,0,vs)
由此，三个关键二次多项式（均为关于 t 的二次）：

p_AA(t) = A(t)·A(t) = c2_AA t^2 + c1_AA t + c0_AA
c2_AA = A1·A1
c1_AA = 2 A0·A1
c0_AA = A0·A0
p_BA(t) = B(t)·A(t) = c2_BA t^2 + c1_BA t + c0_BA
c2_BA = B1·A1
c1_BA = A0·B1 + A1·B0
c0_BA = A0·B0
p_BB(t) = B(t)·B(t) = c2_BB t^2 + c1_BB t + c0_BB
c2_BB = B1·B1
c1_BB = 2 B0·B1
c0_BB = B0·B0
遮蔽判据（单点 P）用

u*(t) = p_BA(t)/p_AA(t)
d_perp^2(t) = p_BB(t) − [p_BA(t)]^2 / p_AA(t)
条件为 0 ≤ u*(t) ≤ 1 且 d_perp^2(t) ≤ R^2
关键简化

在本场景中，p_AA(t) = ||P − M(t)||^2 > 0 对所有 t 恒正（导弹轨迹不穿过 P），因此可放心乘以 p_AA(t) 不改变不等式方向：
u* ≥ 0 ⇔ p_BA ≥ 0
u* ≤ 1 ⇔ p_BA − p_AA ≤ 0
d_perp^2 ≤ R^2 ⇔ p_BB·p_AA − p_BA^2 − R^2·p_AA ≤ 0
其中第三条的左侧是一个四次多项式（quadratic×quadratic − quadratic^2 − constant×quadratic）。
二、数值求根

需要的“边界”由以下多项式的实根给出：
p_BA(t) = 0（u* 的下边界）
p_BA(t) − p_AA(t) = 0（u* 的上边界）
p_D(t) = p_BB(t)·p_AA(t) − [p_BA(t)]^2 − R^2·p_AA(t) = 0（距离条件边界） -（可选）p_AA(t)=0 作为奇点；在本场景中通常无实根，可忽略或仅用于稳健性。
利用 numpy.roots 对每个多项式求根，筛选实根并限制到有效时间窗 [t_e, t_e+life]。
三、区间分析

将所有边界根与时间窗端点合并、去重、排序，得到 t_0 < t_1 < … < t_N。
对每个相邻子区间 (t_i, t_{i+1}) 取中点 t_mid，数值评估三个条件：
cond1: p_BA(t_mid) ≥ 0
cond2: p_BA(t_mid) − p_AA(t_mid) ≤ 0
cond3: p_D(t_mid) ≤ 0（即 d_perp^2 ≤ R^2）
若三者均满足，则将该子区间长度累计到总遮蔽时长。
注意数值容差 eps，避免边界点的浮点误判；重复根与极近根需去重。
四、复杂度与优势

每次评估仅做常数规模的多项式根求解（最高四次），随后是少量区间中点评估，量级远小于符号不等式求解。
对优化器而言，objective 的单次调用大幅加速，整体迭代时间显著缩短。
采用这种思路进行优化，具体代码见第二问（粒子群）.py,
基于上述介绍以及代码文件、问题题目，与latex论文原有内容，帮我创作第二问的论文写作，要求语言风格与前面一致，代码格式与全文统一，语言要求严谨